<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Web Crypto Vault â€“ Demo</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        body { font-family: system-ui, sans-serif; margin: 24px; background: #f8f9fa; color: #222; }
        textarea { width: 100%; height: 120px; font-family: monospace; }
        .row { margin: 12px 0; }
        code { user-select: all; word-break: break-all; }
        hr { margin: 24px 0; }
        .preview {
            margin-top: 16px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        #previewImage, #previewVideo {
            max-width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 8px;
            align-items: center;
        }
        .muted { color: #666; font-size: 12px; }
    </style>
</head>
<body>
<h1>ðŸ”’ Web Crypto Vault â€“ Demo</h1>

<div class="row">
    <button id="btnGenKey">Generate AES-GCM 256 Key</button>
    <button id="btnExportKey" disabled>Export Key (Base64URL)</button>
    <button id="btnImportKey">Import Key (paste below)</button>
</div>
<div class="row">
    <label>Key (Base64URL JWK):</label>
    <textarea id="keyBox" placeholder="Paste a Base64URL key here to import"></textarea>
</div>
<div class="row">
    <label>Passphrase:</label>
    <input type="text" id="passphraseInput" placeholder="Enter a shared passphrase" style="width:100%;" />
</div>
<div class="row" style="display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
    <label style="flex:1 1 240px;">Salt (Base64URL, store next to ciphertext):</label>
    <input type="text" id="saltInput" placeholder="Generate or paste salt" style="flex:2 1 320px;" />
    <button id="btnGenSalt" type="button">Generate Random Salt</button>
</div>
<div class="row muted">
    Reuse the <strong>same passphrase + salt</strong> later to derive the same AES key and decrypt saved ciphertexts.
</div>
<div class="row">
    <button id="btnDeriveKey">Derive/Import Key from Passphrase + Salt</button>
</div>

<hr/>

<h2>RSA-OAEP Key Sharing Demo</h2>
<div class="row">
    <button id="btnShareDemo" type="button">Simulate Bob â†’ Alice Share</button>
</div>
<div class="row">
    <label>Alice Public Key (Base64URL JWK):</label>
    <textarea id="shareAlicePublic" readonly></textarea>
</div>
<div class="row">
    <label>Alice Private Key Backup (Base64URL JWK):</label>
    <textarea id="shareAlicePrivate" readonly></textarea>
</div>
<div class="row">
    <label>Wrapped AES Key for Alice:</label>
    <textarea id="shareWrapped" readonly></textarea>
</div>
<div class="row">
    <label>Unwrapped AES Key (Alice's view):</label>
    <textarea id="shareUnwrapped" readonly></textarea>
</div>
<div class="row muted">
    Generates a new AES key, wraps it with Alice's public RSA key, and verifies that Alice's private key unwraps the same key.
</div>

<hr/>

<h2>Text Test</h2>
<div class="row">
    <textarea id="plainText" placeholder="Write plain text...">Hello, encrypted world!</textarea>
</div>
<div class="row">
    <label><input type="checkbox" id="compressText" checked /> Compress before encrypting (Gzip)</label>
</div>
<div class="row">
    <button id="btnEncText" disabled>Encrypt Text</button>
    <button id="btnDecText" disabled>Decrypt Text</button>
</div>
<div class="row">
    <div class="grid">
        <div>
            <progress id="textProg" value="0" max="100" style="width:100%;"></progress>
            <div id="textProgLabel" class="muted">0%</div>
        </div>
        <button id="btnCancelText" class="muted" title="Cancel current text op">Cancel</button>
    </div>
</div>
<div class="row">
    <label>Ciphertext (Base64URL):</label>
    <textarea id="cipherText" placeholder="It will appear here..."></textarea>
</div>

<hr/>

<h2>Files / Blobs (images, videos, pdf, etc.)</h2>
<div class="row">
    <input type="file" id="fileInput" />
</div>
<div class="row">
    <label><input type="checkbox" id="compressFile" checked /> Compress before encrypting (Gzip)</label>
    <label style="margin-left:16px;">Chunk size: <input type="number" id="chunkSize" value="1048576" min="65536" step="65536"/> bytes</label>
</div>
<div class="row">
    <button id="btnEncFile" disabled>Encrypt File</button>
    <button id="btnDecFile" disabled>Decrypt File â†’ Show Preview</button>
</div>
<div class="row">
    <div class="grid">
        <div>
            <progress id="fileProg" value="0" max="100" style="width:100%;"></progress>
            <div id="fileProgLabel" class="muted">0%</div>
        </div>
        <div style="display:flex; gap:8px;">
            <button id="btnCancelEnc" class="muted" title="Cancel encryption">Cancel Encrypt</button>
            <button id="btnCancelDec" class="muted" title="Cancel decryption">Cancel Decrypt</button>
        </div>
    </div>
</div>
<div class="row">
    <label>Ciphertext (Base64URL):</label>
    <textarea id="cipherBlob" placeholder="It will appear here..."></textarea>
</div>

<!-- Preview section -->
<div class="preview">
    <img id="previewImage" alt="Decrypted image preview" style="display:none;">
    <video id="previewVideo" controls style="display:none;"></video>
</div>

<script type="module">
    import {
        generateAesKey, exportKeyToBase64, importKeyFromBase64,
        encryptString, decryptToString,
        encryptBlob, decryptToBlob,
        deriveKeyFromPassphrase, SALT_BYTES,
        generateRsaKeyPair, wrapKeyForRecipient, unwrapKeyForRecipient,
        exportPublicKeyToBase64, exportPrivateKeyToBase64,
        importPublicKeyFromBase64, importPrivateKeyFromBase64,
        toBase64Url, fromBase64Url,
    } from "./dist/index.js";

    let KEY = null;
    let lastPackedBlob = "";

    // AbortControllers for each op
    let encFileController = null;
    let decFileController = null;
    let textController = null;

    // Helpers
    const $ = (id) => document.getElementById(id);
    const enableKeyActions = (on) => {
        ["btnExportKey","btnEncText","btnDecText","btnEncFile","btnDecFile"].forEach(id => $(id).disabled = !on);
    };
    const resetTextProgress = () => { $("textProg").value = 0; $("textProgLabel").textContent = "0%"; };
    const resetFileProgress = () => { $("fileProg").value = 0; $("fileProgLabel").textContent = "0%"; };
    const setBusy = (busy) => {
        // Basic UI lock to avoid double clicks; adapt as you like
        document.querySelectorAll("button, input, textarea").forEach(el => {
            if (el.id?.startsWith("btnCancel")) return; // keep cancel buttons active
            el.disabled = busy ? true : el.disabled;
        });
    };

    $("btnGenKey").addEventListener("click", async () => {
        KEY = await generateAesKey();
        enableKeyActions(true);
        alert("Key generated!");
    });

    $("btnExportKey").addEventListener("click", async () => {
        if (!KEY) return;
        $("keyBox").value = await exportKeyToBase64(KEY);
    });

    $("btnImportKey").addEventListener("click", async () => {
        const b64 = $("keyBox").value.trim();
        if (!b64) return alert("Paste a Base64URL key first.");
        try {
            KEY = await importKeyFromBase64(b64);
            enableKeyActions(true);
            alert("Key imported!");
        } catch {
            alert("Invalid key.");
        }
    });

    $("btnGenSalt").addEventListener("click", () => {
        const salt = crypto.getRandomValues(new Uint8Array(SALT_BYTES));
        $("saltInput").value = toBase64Url(salt);
    });

    $("btnDeriveKey").addEventListener("click", async () => {
        const passphrase = $("passphraseInput").value;
        if (!passphrase) return alert("Enter a passphrase first.");
        const saltB64 = $("saltInput").value.trim();
        if (!saltB64) return alert("Generate or paste a salt.");
        let salt;
        try {
            salt = fromBase64Url(saltB64);
        } catch {
            return alert("Salt must be valid Base64URL.");
        }
        if (salt.length !== SALT_BYTES) {
            return alert(`Salt must be ${SALT_BYTES} bytes (Base64URL string).`);
        }
        try {
            KEY = await deriveKeyFromPassphrase(passphrase, salt);
            enableKeyActions(true);
            alert("Key derived from passphrase!");
        } catch (err) {
            console.error(err);
            alert("Could not derive key.");
        }
    });

    // TEXT ENCRYPT / DECRYPT with minimal progress (0 â†’ 100)
    $("btnEncText").addEventListener("click", async () => {
        if (!KEY) return;
        const plain = $("plainText").value;
        const compress = $("compressText").checked;

        textController?.abort(); // cancel previous
        textController = new AbortController();

        resetTextProgress();
        $("textProgLabel").textContent = "Encrypting...";
        try {
            const packed = await encryptString(plain, KEY, { compress });
            // No granular progress from encryptString; set to 100% when done:
            $("textProg").value = 100; $("textProgLabel").textContent = "100%";
            $("cipherText").value = packed;
        } catch (e) {
            if (e.name === "AbortError") {
                $("textProgLabel").textContent = "Canceled.";
            } else {
                console.error(e);
                $("textProgLabel").textContent = "Error.";
                alert("Error encrypting text.");
            }
        } finally {
            textController = null;
        }
    });

    $("btnDecText").addEventListener("click", async () => {
        if (!KEY) return;
        const packed = $("cipherText").value.trim();
        if (!packed) return;

        textController?.abort();
        textController = new AbortController();

        resetTextProgress();
        $("textProgLabel").textContent = "Decrypting...";
        try {
            const plain = await decryptToString(packed, KEY, {
                signal: textController.signal,
                onProgress: ({ percent }) => { $("textProg").value = percent; $("textProgLabel").textContent = `${percent}%`; }
            });
            $("plainText").value = plain;
            $("textProg").value = 100; $("textProgLabel").textContent = "100%";
        } catch (e) {
            if (e.name === "AbortError") {
                $("textProgLabel").textContent = "Canceled.";
            } else {
                console.error(e);
                $("textProgLabel").textContent = "Error.";
                alert("Error decrypting text.");
            }
        } finally {
            textController = null;
        }
    });

    $("btnCancelText").addEventListener("click", () => textController?.abort());

    // FILE ENCRYPT with granular progress
    $("btnEncFile").addEventListener("click", async () => {
        if (!KEY) return;
        const file = $("fileInput").files?.[0];
        if (!file) return alert("Select a file first.");
        const compress = $("compressFile").checked;
        const chunkSize = parseInt($("chunkSize").value || "1048576", 10);

        encFileController?.abort();
        encFileController = new AbortController();

        resetFileProgress();
        $("fileProgLabel").textContent = "Encrypting...";
        try {
            const packed = await encryptBlob(file, KEY, {
                compress,
                chunkSize,
                signal: encFileController.signal,
                onProgress: ({ percent, processed, total }) => {
                    $("fileProg").value = percent;
                    $("fileProgLabel").textContent = `${percent}% (${processed}/${total} bytes)`;
                }
            });
            $("cipherBlob").value = packed;
            lastPackedBlob = packed;
            $("fileProg").value = 100; $("fileProgLabel").textContent = "100%";
            alert("File encrypted and serialized to Base64URL.");
        } catch (e) {
            if (e.name === "AbortError") {
                $("fileProgLabel").textContent = "Canceled.";
            } else {
                console.error(e);
                $("fileProgLabel").textContent = "Error.";
                alert("Error encrypting file.");
            }
        } finally {
            encFileController = null;
        }
    });

    $("btnCancelEnc").addEventListener("click", () => encFileController?.abort());

    // FILE DECRYPT with granular progress + preview
    $("btnDecFile").addEventListener("click", async () => {
        if (!KEY) return;
        const packed = $("cipherBlob").value.trim() || lastPackedBlob;
        if (!packed) return alert("No encrypted content.");

        decFileController?.abort();
        decFileController = new AbortController();

        resetFileProgress();
        $("fileProgLabel").textContent = "Decrypting...";
        try {
            const blob = await decryptToBlob(packed, KEY, {
                signal: decFileController.signal,
                onProgress: ({ percent, processed, total }) => {
                    $("fileProg").value = percent;
                    $("fileProgLabel").textContent = `${percent}% (${processed}/${total} bytes)`;
                }
            });
            $("fileProg").value = 100; $("fileProgLabel").textContent = "100%";

            const url = URL.createObjectURL(blob);

            // Hide both first
            $("previewImage").style.display = "none";
            $("previewVideo").style.display = "none";

            // Show by MIME
            if (blob.type.startsWith("image/")) {
                $("previewImage").src = url;
                $("previewImage").style.display = "block";
            } else if (blob.type.startsWith("video/")) {
                $("previewVideo").src = url;
                $("previewVideo").style.display = "block";
            } else {
                alert(`Decrypted file type: ${blob.type}. Downloading instead.`);
                const a = document.createElement("a");
                a.href = url;
                a.download = "decrypted_" + (blob.type?.split("/")[1] || "bin");
                a.click();
            }
        } catch (e) {
            if (e.name === "AbortError") {
                $("fileProgLabel").textContent = "Canceled.";
            } else {
                console.error(e);
                $("fileProgLabel").textContent = "Error.";
                alert("Error decrypting file.");
            }
        } finally {
            decFileController = null;
        }
    });

    $("btnCancelDec").addEventListener("click", () => decFileController?.abort());

    $("btnShareDemo").addEventListener("click", async () => {
        const button = $("btnShareDemo");
        button.disabled = true;
        try {
            const alicePair = await generateRsaKeyPair();
            const dataKey = await generateAesKey();

            const alicePublicB64 = await exportPublicKeyToBase64(alicePair.publicKey);
            const alicePrivateB64 = await exportPrivateKeyToBase64(alicePair.privateKey);
            const bobViewPublic = await importPublicKeyFromBase64(alicePublicB64);
            const wrapped = await wrapKeyForRecipient(bobViewPublic, dataKey);

            const aliceViewPrivate = await importPrivateKeyFromBase64(alicePrivateB64);
            const unwrapped = await unwrapKeyForRecipient(wrapped, aliceViewPrivate);

            const bobSerialized = await exportKeyToBase64(dataKey);
            const aliceSerialized = await exportKeyToBase64(unwrapped);

            $("shareAlicePublic").value = alicePublicB64;
            $("shareAlicePrivate").value = alicePrivateB64;
            $("shareWrapped").value = wrapped;
            $("shareUnwrapped").value = `${aliceSerialized}\n${aliceSerialized === bobSerialized ? "(Matches Bob's key)" : "(Mismatch!)"}`;
        } catch (err) {
            console.error(err);
            alert("Key sharing simulation failed.");
        } finally {
            button.disabled = false;
        }
    });

    // init
    enableKeyActions(false);
</script>
</body>
</html>